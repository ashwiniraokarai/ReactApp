{"version":3,"sources":["components/navbar.jsx","components/counter.jsx","components/counters.jsx","App.js","serviceWorker.js","index.js"],"names":["NavBar","state","Fragment","className","href","this","props","totalCounters","Component","Counter","tags","styles","fontSize","fontWeight","console","log","style","getBadgeClasses","getCount","onClick","onIncrement","countersArrayObject","onDelete","id","getList","badgeClasses","countLocal","count","list","map","tag","key","length","Counters","onReset","countersArray","counterLocal","App","handleIncrementButton","countersArrayWithIncrement","arrayIndex","indexOf","setState","handleDeleteButton","counterLocalID","countersArrayWithDelete","filter","c","handleResetButton","countersArrayWithReset","element","role","class","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d62d655e.chunk.js","sourcesContent":["import React from \"react\";\r\nimport { Component } from \"react\";\r\n\r\nclass NavBar extends Component {\r\n  state = {};\r\n  render() {\r\n    return (\r\n      <React.Fragment>\r\n        <nav className=\"navbar navbar-light bg-light\">\r\n          <a className=\"navbar-brand\" href=\"#\">\r\n            Navbar{\" \"}\r\n            <span className=\"badge badge-pill badge-secondary\">\r\n              {this.props.totalCounters}\r\n            </span>\r\n          </a>\r\n        </nav>\r\n      </React.Fragment>\r\n    );\r\n  }\r\n}\r\n\r\nexport default NavBar;\r\n","import React, { Component } from \"react\";\r\n\r\nclass Counter extends Component {\r\n  state = {\r\n    //the line below can be removed safely. Keeping it here for history of evolution. the state of this component is now being controlled by its parent(counters component) via props.\r\n    //count: this.props.countLocal,\r\n    //image: \"https://picsum.photos/200\"\r\n    tags: [\"subitem1\", \"subitem2\", \"subitem3\"]\r\n  };\r\n\r\n  styles = {\r\n    fontSize: 15,\r\n    fontWeight: \"bold\"\r\n  };\r\n\r\n  render() {\r\n    console.log(this.props);\r\n    return (\r\n      <React.Fragment>\r\n        {/* <img src={this.state.image} alt=\"natural scenery\" /> */}\r\n        <span style={this.styles} className={this.getBadgeClasses()}>\r\n          {/*className value is equal to badgeClasses value, which is determined by the if-condition evaluation in the getBadgeClasses() method that className is assigned to call*/}\r\n          {this.getCount()}\r\n        </span>\r\n        <button\r\n          style={{ fontSize: 18 }}\r\n          className=\"btn btn-secondary btn-sm m-2\"\r\n          onClick={() => {\r\n            this.props.onIncrement(this.props.countersArrayObject);\r\n          }}\r\n        >\r\n          Increment\r\n        </button>\r\n        <button\r\n          className=\"m-2 btn btn-danger btn-sm\"\r\n          onClick={() => {\r\n            this.props.onDelete(this.props.id);\r\n          }}\r\n        >\r\n          Delete\r\n        </button>\r\n        <div>{this.getList()}</div>\r\n      </React.Fragment>\r\n    );\r\n  }\r\n\r\n  //If count = 0, then badge classes we want are: badge, m-2, badge-warning (yellow color). Otherwise, we want badge, m-2, badge-primary (blue color)\r\n  getBadgeClasses() {\r\n    let badgeClasses = \"badge m-2\";\r\n    badgeClasses +=\r\n      this.props.countLocal === 0 ? \" badge-warning\" : \" badge-primary\";\r\n    return badgeClasses;\r\n  }\r\n\r\n  getCount() {\r\n    //Notice the ABSENCE of function keyword since the function is inside a class\r\n    var count = this.props.countLocal;\r\n    return count === 0 ? \"zero\" : count;\r\n  }\r\n\r\n  getList() {\r\n    let errorMessage = \"No tags to display\";\r\n    let list = (\r\n      <ul>\r\n        {this.state.tags.map(function(tag) {\r\n          return <li key={tag}>{tag}</li>;\r\n        })}\r\n      </ul>\r\n    );\r\n\r\n    return this.state.tags.length === 0 ? errorMessage : list;\r\n  }\r\n}\r\n\r\nexport default Counter;\r\n","import React from \"react\";\r\nimport { Component } from \"react\";\r\nimport Counter from \"./counter.jsx\";\r\n\r\nclass Counters extends Component {\r\n  //state object used to be here\r\n  render() {\r\n    return (\r\n      <div>\r\n        <div>\r\n          <button\r\n            onClick={this.props.onReset}\r\n            className=\"btn btn-primary btn-sm m-2\"\r\n          >\r\n            Reset\r\n          </button>\r\n        </div>\r\n        {this.props.countersArray.map(counterLocal => (\r\n          <Counter\r\n            key={counterLocal.id}\r\n            countLocal={counterLocal.count}\r\n            onDelete={this.props.onDelete}\r\n            onIncrement={this.props.onIncrement}\r\n            id={counterLocal.id}\r\n            countersArrayObject={counterLocal}\r\n          />\r\n        ))}\r\n      </div>\r\n    );\r\n  } //end render()\r\n\r\n  //handleIncrementButton method used to be here\r\n  //handleDeleteButton method used to be here\r\n  //handleResetButton method used to be here\r\n} //end class\r\n\r\nexport default Counters;\r\n","import React from \"react\";\nimport { Component } from \"react\";\nimport \"./App.css\";\nimport NavBar from \"./components/navbar.jsx\";\nimport Counters from \"./components/counters.jsx\";\nimport { throwStatement } from \"@babel/types\";\n\nclass App extends Component {\n  //state object was moved up from counters component\n  state = {\n    countersArray: [\n      { id: 1, count: 4 },\n      { id: 2, count: 3 },\n      { id: 3, count: 2 },\n      { id: 4, count: 1 }\n    ]\n  };\n  render() {\n    return (\n      <React.Fragment>\n        <NavBar\n          totalCounters={\n            this.state.countersArray.filter(element => {\n              return element.count > 0;\n            }).length\n          }\n        />\n        <main role=\"main\" class=\"container\">\n          <Counters\n            countersArray={this.state.countersArray}\n            onIncrement={this.handleIncrementButton}\n            onDelete={this.handleDeleteButton}\n            onReset={this.handleResetButton}\n          />\n        </main>\n      </React.Fragment>\n    );\n  } //end render()\n\n  //handleIncrementButton method was moved up from counters component\n  //----------------------------------------------------------------------------------------------------------------------------------\n  //Increment button lives in counter component but is HANDLED in this component because the array it affects (counterArray) is OWNED by this component.\n  //This method is made available to counter component via the onIncrement attribute and acccessed by counter component vis this.Props\n  handleIncrementButton = countersArrayObject => {\n    //Making sure id from state object is flowing through a.k.a test the plumbing first\n    console.log(\n      \"From handleIncrementButton() in counters component. counter id: \",\n      countersArrayObject\n    );\n    //Create a copy/clone the countersArray array using the \"spread\" operator.NOTE: array.map can be used an alternative to simply return every element of the array\n    const countersArrayWithIncrement = [...this.state.countersArray];\n    //Grab the array index of the passed in array element(object) using indexOf() method and store it to const.\n    const arrayIndex = countersArrayWithIncrement.indexOf(countersArrayObject);\n    //Using the index, access and operate on the specific element in the copied array\n    //If you simply increment the count value like below, it affects the original state array directly, because of how object in array and Spread Operator work in JS (remember, that's not desirable. You need to change values only through setState)\n    //countersArrayWithIncrement[countersArrayObjectIndex].count += 1;\n    //Therefore, i) you need to OBTAIN a COPY of the OBJECT WITHIN THE ARRAY (i.e, the element), ii) overwrite the ORIGINAL with the COPY AFTER which iii) you can operate on the copied element instead. Here we are OVERWRITING the array element with a copy\n    //{ ...countersArrayWithIncrement[arrayIndex] } gives you a COPY of the object. By assigning it to the object countersArrayWithIncrement[arrayIndex], we OVERWRITE the original object with the NEW object (copy). So. it's pointing to a NEW object altogether.\n    countersArrayWithIncrement[arrayIndex] = {\n      ...countersArrayWithIncrement[arrayIndex]\n    };\n    countersArrayWithIncrement[arrayIndex].count += 1;\n    /* The above 2 steps are equivalent to these 3 steps:\n      const objectWithIncrement = { ...countersArrayWithIncrement[arrayIndex] };\n  \n      //Update (increment) the copy of the object\n      objectWithIncrement.count += 1;\n  \n      //Replace the object in the copied array with the updated element\n      countersArrayWithIncrement[arrayIndex] = objectWithIncrement;\n      */\n    //TEST THE ORIGINAL ARRAY in STATE BEFORE YOU FINALLY SET STATE (STATE should NOT have got affected because you haven't set it yet. If this gives an incremented value, we have a problem)\n    //console.log(this.state.countersArray[arrayIndex]);\n    //Set State\n    this.setState({\n      countersArray: countersArrayWithIncrement\n    });\n  }; //end handleIncrementButton\n\n  //handleDeleteButton method was moved up from counters component\n  //----------------------------------------------------------------------------------------------------------------------------------\n  //Delete button lives in counter component but is HANDLED in this component because the array it affects (counterArray) is OWNED by this component.\n  //This method is made available to counter component via the onDelete attribute and acccessed by counter component vis this.Props\n  handleDeleteButton = counterLocalID => {\n    //Making sure id from props is flowing through\n    console.log(\n      \"From handleDeleteButton() in counters component. counter id: \",\n      counterLocalID\n    );\n    //Build a NEW array same as the countersArray EXCEPT the id that needs to be DELETED\n    const countersArrayWithDelete = this.state.countersArray.filter(\n      c => c.id !== counterLocalID\n    );\n    //set the countersArray (an array AND a property of the state OBJECT) to the NEW array that has the desired array element removed\n    this.setState({ countersArray: countersArrayWithDelete });\n  };\n\n  //handleResetButton method was moved up from counters component\n  //----------------------------------------------------------------------------------------------------------------------------------\n  handleResetButton = () => {\n    //set count value of every object in this.state.countersArray to 0\n    const countersArrayWithReset = this.state.countersArray.map(c => {\n      c.count = 0;\n      return c; //since you have a \"block\" i.e, statements wrapped in {}, you'll need to do an explicit return of the object even though it's an arrow function\n    });\n    this.setState({ countersArray: countersArrayWithReset });\n  };\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.css\";\nimport Counters from \"./components/counters.jsx\";\n\n//TEST with some basic mark-up: ReactDOM.render(<h1>hullo</h1>, document.getElementById(\"root\"));\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n//ReactDOM.render(<Counters />, document.getElementById(\"root\"));\n\n//ReactDOM.render(<Counter />, document.getElementById(\"root\"));\n\n/*Ash - Remember:\n//your index.html has come predefined with a div with id=\"root\", which is the primary container for your app. You're simply referencing that html element here\n//Counter is the class you created in your component counter.jsx. Ideally, you'd call your App class/function here instead\n//You can also write ANY markup like <h1>hello world</h1> instead to keep is super super simple:\n    //ReactDOM.render(<h1>hullo</h1>, document.getElementById(\"root\")); will render simply that: hullo.\n*/\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}